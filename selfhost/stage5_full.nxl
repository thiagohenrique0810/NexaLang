
# Stage 5: Self-Hosted Compiler (Single File)
# Includes: Helpers, AST, Lexer, Parser, CodeGen

# --- Helpers ---

fn is_alpha(c: u8) -> bool {
    let x: i32 = cast::<i32>(c);
    if (x > 64) { if (x < 91) { return true; } }     # A-Z
    if (x > 96) { if (x < 123) { return true; } }    # a-z
    if (x == 95) { return true; }                    # _
    return false;
}

fn is_digit(c: u8) -> bool {
    let x: i32 = cast::<i32>(c);
    if (x > 47) { if (x < 58) { return true; } }
    return false;
}

fn is_space(c: u8) -> bool {
    let x: i32 = cast::<i32>(c);
    if (x == 32) { return true; }  # space
    if (x == 9) { return true; }   # \t
    if (x == 10) { return true; }  # \n
    if (x == 13) { return true; }  # \r
    return false;
}

fn strlen(s: string) -> i32 {
    let p: u8* = cast::<u8*>(s);
    let i: i32 = 0;
    while (true) {
        let c: u8 = p[i];
        if (cast::<i32>(c) == 0) { return i; }
        i = i + 1;
    }
    return 0;
}



fn streq(a: string, b: string) -> bool {
    let pa: u8* = cast::<u8*>(a);
    let pb: u8* = cast::<u8*>(b);
    let i: i32 = 0;
    while (true) {
        let ca: u8 = pa[i];
        let cb: u8 = pb[i];
        if (cast::<i32>(ca) == 0) {
            if (cast::<i32>(cb) == 0) { return true; }
            return false;
        }
        if (cast::<i32>(cb) == 0) { return false; }
        if (cast::<i32>(ca) != cast::<i32>(cb)) { return false; }
        i = i + 1;
    }
    return true;
}

fn ptr_offset<T>(ptr: *T, offset: i32) -> *T {
    # Simple pointer arithmetic
    let addr: u64 = cast::<u64>(ptr);
    # offset is in elements, so multiply by sizeof
    let byte_offset: u64 = cast::<u64>(offset) * cast::<u64>(sizeof::<T>());
    return cast::<*T>(addr + byte_offset);
}

# --- Arena Allocator ---

struct Arena {
    chunk: u8*,
    offset: i32,
    capacity: i32
}

fn arena_init(size: i32) -> Arena {
    let chunk: u8* = malloc(size);
    return Arena(chunk, 0, size);
}

fn arena_alloc(a: *Arena, size: i32) -> u8* {
    let off: i32 = (*a).offset;
    if (off + size > (*a).capacity) {
        panic("Arena out of memory");
    }
    let ptr: u8* = ptr_offset::<u8>((*a).chunk, off);
    (*a).offset = off + size;
    return ptr;
}

# --- AST Definitions ---

enum Expr {
    Int(i32),
    Str(string)
}

enum Stmt {
    Return(Expr),
    Print(Expr)
}

# --- Specialized Slices ---

struct SliceStmt {
    ptr: *Stmt,
    len: i32
}

struct Function {
    name_start: i32,
    name_len: i32,
    body: SliceStmt
}

struct SliceFunction {
    ptr: *Function,
    len: i32
}

struct Program {
    functions: SliceFunction
}

# --- Lexer ---

struct Token {
    kind: i32,   # 0=eof, 1=ident, 2=number, 3=string, 4=char, 5=op
    start: i32,
    len: i32
}

fn push_token(tokens: *Token, count: *i32, kind: i32, start: i32, len: i32) {
    let idx: i32 = *count;
    tokens[idx] = Token(kind, start, len);
    *count = idx + 1;
}

fn lex_all(p: *u8, n: i32, tokens: *Token, count: *i32) {
    let i: i32 = 0;
    while (i < n) {
        let c: u8 = p[i];
        if (is_space(c)) {
            i = i + 1;
        } else {
            if (cast::<i32>(c) == 35) { # #
                let j: i32 = i + 1;
                while (j < n) {
                    if (cast::<i32>(p[j]) == 10) { i = j; j = n; } else { j = j + 1; }
                }
            } else {
                if (cast::<i32>(c) == 34) { # "
                    let start: i32 = i;
                    let j: i32 = i + 1;
                    while (j < n) {
                        if (cast::<i32>(p[j]) == 34) { j = j + 1; i = j; j = n; }
                        else { j = j + 1; }
                    }
                    push_token(tokens, count, 3, start, i - start);
                } else {
                    if (is_alpha(c)) {
                        let start: i32 = i;
                        let j: i32 = i + 1;
                        while (j < n) {
                            let is_match: bool = false;
                            if (is_alpha(p[j])) { is_match = true; }
                            else { if (is_digit(p[j])) { is_match = true; } }
                            
                            if (is_match) { j = j + 1; } else { i = j; j = n; }
                        }
                        push_token(tokens, count, 1, start, i - start);
                    } else {
                        if (is_digit(c)) {
                            let start: i32 = i;
                            let j: i32 = i + 1;
                            while (j < n) {
                                if (is_digit(p[j])) { j = j + 1; } else { i = j; j = n; }
                            }
                            push_token(tokens, count, 2, start, i - start);
                        } else {
                            push_token(tokens, count, 5, i, 1);
                            i = i + 1;
                        }
                    }
                }
            }
        }
    }
    push_token(tokens, count, 0, n, 0);
}

# --- Parser ---

struct Parser {
    src: *u8,
    tokens: *Token,
    pos: i32,
    count: i32,
    arena: *Arena
}

fn parser_init(src: *u8, tokens: *Token, count: i32, arena: *Arena) -> Parser {
    return Parser(src, tokens, 0, count, arena);
}

fn check(p: *Parser, kind: i32) -> bool {
    let t: *Token = ptr_offset::<Token>((*p).tokens, (*p).pos);
    return ((*t).kind == kind);
}

fn consume(p: *Parser, kind: i32) -> Token {
    let t: *Token = ptr_offset::<Token>((*p).tokens, (*p).pos);
    if ((*t).kind == kind) {
        (*p).pos = (*p).pos + 1;
        return *t;
    }
    panic("Unexpected token");
    return *t;
}

fn parse_expr(p: *Parser) -> Expr {
    # Int or Str
    let t: *Token = ptr_offset::<Token>((*p).tokens, (*p).pos);
    if ((*t).kind == 2) { # Number (Int)
        consume(p, 2);
        # Parse int (todo: implement atoi)
        return Expr::Int(123);
    }
    if ((*t).kind == 3) { # String
        consume(p, 3);
        return Expr::Str("ParsedString");
    }
    panic("Expected expression");
    return Expr::Int(0);
}

fn parse_stmt(p: *Parser) -> Stmt {
    let t: *Token = ptr_offset::<Token>((*p).tokens, (*p).pos);
    # Check for keywords? 'return', 'print'
    # TODO: Implement proper keyword checking using src lookup
    
    # Assuming 'return' for now if it's an Identifier
    if ((*t).kind == 1) { 
        # Check keyword content... 
        # For simplicity in this step, let's assume 'print'
        consume(p, 1);
        consume(p, 5); # (
        let e: Expr = parse_expr(p);
        consume(p, 5); # )
        consume(p, 5); # ;
        return Stmt::Print(e);
    }
    
    panic("Unknown statement");
    return Stmt::Print(Expr::Int(0));
}

fn parse_fn(p: *Parser) -> Function {
    # fn name() { ... }
    consume(p, 1); # fn (kw)
    let name_tok: Token = consume(p, 1); # name
    consume(p, 5); # (
    consume(p, 5); # )
    consume(p, 5); # {
    
    # Body
    let stmts_ptr: *Stmt = cast::<*Stmt>(arena_alloc((*p).arena, 10 * sizeof::<Stmt>()));
    let cnt: i32 = 0;
    let t: *Token = ptr_offset::<Token>((*p).tokens, (*p).pos);
    
    # Loop until '}' (char 125)
    # Check if cur token is op '}'
    # We need to peek raw char from src... 
    let s: i32 = (*t).start;
    let c: u8 = ptr_offset::<u8>((*p).src, s)[0];
    
    # Very manual check for '}'
    while (cast::<i32>(c) != 125) {
        let stmt: Stmt = parse_stmt(p);
        stmts_ptr[cnt] = stmt;
        cnt = cnt + 1;
        
        t = ptr_offset::<Token>((*p).tokens, (*p).pos);
        s = (*t).start;
        c = ptr_offset::<u8>((*p).src, s)[0];
    }
    consume(p, 5); # }
    
    return Function(name_tok.start, name_tok.len, SliceStmt(stmts_ptr, cnt));
}

fn parse_prog(p: *Parser) -> Program {
    let funcs_ptr: *Function = cast::<*Function>(arena_alloc((*p).arena, 10 * sizeof::<Function>()));
    let cnt: i32 = 0;
    
    while ((*p).pos < (*p).count - 1) { # -1 for EOF check
        funcs_ptr[cnt] = parse_fn(p);
        cnt = cnt + 1;
    }
    
    return Program(SliceFunction(funcs_ptr, cnt));
}

# --- CodeGen ---

fn emit_ll(prog: Program) {
    let out: string = "dev/artifacts/output.ll";
    fs::write_file(out, "; ModuleID = 'selfhost'\n", 24);
    fs::append_file(out, "declare i32 @printf(i8*, ...)\n", 30);
    fs::append_file(out, "@fmt = private constant [4 x i8] c\"%d\\0A\\00\"\n", 43);
    
    let i: i32 = 0;
    while (i < prog.functions.len) {
        let f: Function = prog.functions.ptr[i];
        # Emit function header (main only for now)
        fs::append_file(out, "define i32 @main() {\nentry:\n", 28);
        
        # Emit body
        let j: i32 = 0;
        while (j < f.body.len) {
            let s: Stmt = f.body.ptr[j];
            match s {
                Print(e) => {
                     match e {
                        Int(val) => {
                             fs::append_file(out, "  %p = call i32 (i8*, ...) @printf(i8* getelementptr ([4 x i8], [4 x i8]* @fmt, i32 0, i32 0), i32 123)\n", 100);
                        }
                        Str(val) => {}
                     }
                }
                Return(e) => {}
            }
            j = j + 1;
        }
        
        fs::append_file(out, "  ret i32 0\n}\n", 13);
        i = i + 1;
    }
    
    print("Emitted LLVM IR to dev/artifacts/output.ll");
}

# --- Main ---

fn main() -> i32 {
    print("Starting Self-Host Compiler...");
    
    # 1. Read Lexer
    let src_buf: Buffer<u8> = fs::read_file("examples/hello.nxl");
    
    # 2. Tokenize
    let max_toks: i32 = 1000;
    let tok_bytes: i32 = max_toks * sizeof::<Token>();
    let tokens: *Token = cast::<*Token>(malloc(tok_bytes));
    let count: i32 = 0;
    lex_all(src_buf.ptr, src_buf.len, tokens, &count);
    print("Lexed tokens.");
    
    # 3. Parse
    let mem: Arena = arena_init(1024 * 1024); # 1MB
    let parser: Parser = parser_init(src_buf.ptr, tokens, count, &mem);
    let prog: Program = parse_prog(&parser);
    print("Parsed AST.");
    
    # 4. CodeGen
    emit_ll(prog);
    
    return 0;
}
