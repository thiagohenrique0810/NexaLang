struct String {
    ptr: *u8,
    len: i32,
    cap: i32
}

# Helpers
fn strlen(s: *u8) -> i32 {
    let i: i32 = 0;
    while (true) {
        let p: *u8 = ptr_offset::<u8>(s, i);
        if (cast::<i32>(*p) == 0) { return i; }
        i = i + 1;
    }
    return 0; # Unreachable
}

fn string_new(s: *u8) -> String {
    let len: i32 = strlen(s);
    let cap: i32 = len + 1; # Null terminator
    
    let ptr: *u8 = malloc(cap);
    
    # Copy string including null terminator
    # memcpy(dest, src, size)
    memcpy(ptr, s, cap);
    
    return String(ptr, len, cap);
}

fn string_concat(s1: *String, s2: *String) -> String {
    let len: i32 = (*s1).len + (*s2).len;
    let cap: i32 = len + 1;
    
    let ptr: *u8 = malloc(cap);
    
    # Copy s1
    if ((*s1).len > 0) {
        memcpy(ptr, (*s1).ptr, (*s1).len);
    }
    
    # Copy s2
    if ((*s2).len > 0) {
        let dest: *u8 = ptr_offset::<u8>(ptr, (*s1).len);
        memcpy(dest, (*s2).ptr, (*s2).len);
    }
    
    # Null terminate
    let end: *u8 = ptr_offset::<u8>(ptr, len);
    *end = cast::<u8>(0);
    
    return String(ptr, len, cap);
}

fn print_string(s: *String) {
    print((*s).ptr);
}

fn main() {
    let h: String = string_new("Hello");
    let w: String = string_new(" World");
    
    let hw: String = string_concat(&h, &w);
    
    print_string(&h);
    print_string(&w);
    print_string(&hw);
    
    print(hw.len);
    
    free(h.ptr);
    free(w.ptr);
    free(hw.ptr);
}
