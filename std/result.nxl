pub enum Result<T, E> {
    Ok(T),
    Err(E)
}

impl<T, E> Result<T, E> {
    fn is_ok(&self) -> bool {
        let s = *self;
        match (s) {
            Ok(_) => return true,
            Err(_) => return false,
        }
    }

    fn is_err(&self) -> bool {
        if (self.is_ok()) {
            return false;
        }
        return true;
    }

    fn unwrap(self) -> T {
        let s = self;
        match (s) {
            Ok(val) => return val,
            Err(_) => {
                panic("called `Result::unwrap()` on an `Err` value");
            }
        }
    }

    fn unwrap_or(self, default: T) -> T {
        let s = self;
        match (s) {
            Ok(val) => return val,
            Err(_) => return default,
        }
    }

    fn map<U, F: fn(T) -> U>(self, f: F) -> Result<U, E> {
        let s = self;
        match (s) {
            Ok(v) => return Result::<U, E>::Ok(f(v)),
            Err(e) => return Result::<U, E>::Err(e),
        }
    }

    fn and_then<U, F: fn(T) -> Result<U, E>>(self, f: F) -> Result<U, E> {
        let s = self;
        match (s) {
            Ok(v) => return f(v),
            Err(e) => return Result::<U, E>::Err(e),
        }
    }
}
