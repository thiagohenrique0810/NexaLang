struct Token {
    kind: i32,   # 0=eof, 1=ident, 2=number, 3=string, 4=char, 5=op
    start: i32,
    len: i32
}

fn is_alpha(c: u8) -> bool {
    let x: i32 = cast::<i32>(c)
    if (x > 64) { if (x < 91) { return true } }     # A-Z
    if (x > 96) { if (x < 123) { return true } }    # a-z
    if (x == 95) { return true }                    # _
    return false
}

fn is_digit(c: u8) -> bool {
    let x: i32 = cast::<i32>(c)
    if (x > 47) { if (x < 58) { return true } }
    return false
}

fn is_space(c: u8) -> bool {
    let x: i32 = cast::<i32>(c)
    if (x == 32) { return true }  # space
    if (x == 9) { return true }   # \t
    if (x == 10) { return true }  # \n
    if (x == 13) { return true }  # \r
    return false
}

fn push_token(tokens: *Token, count: *i32, kind: i32, start: i32, len: i32) {
    let idx: i32 = *count;
    tokens[idx] = Token(kind, start, len);
    *count = idx + 1;
}

fn main() -> i32 {
    let src: Buffer<u8> = fs::read_file("examples/control.nxl")
    let p: *u8 = src.ptr
    let n: i32 = src.len

    # allocate space for up to 4096 tokens
    let cap: i32 = 4096
    let bytes: i32 = cap * sizeof::<Token>()
    let raw: *u8 = malloc(bytes)
    let tokens: *Token = cast::<*Token>(raw)
    let count: i32 = 0

    let i: i32 = 0
    while (i < n) {
        let c: u8 = p[i]

        # whitespace
        if (is_space(c)) {
            i = i + 1
        } else {
            # comment: # ... \n
            if (cast::<i32>(c) == 35) {
                let j: i32 = i + 1
                while (j < n) {
                    if (cast::<i32>(p[j]) == 10) { i = j; j = n } else { j = j + 1 }
                }
            } else {
                # string: "..."
                if (cast::<i32>(c) == 34) {
                    let start: i32 = i
                    let j: i32 = i + 1
                    while (j < n) {
                        let cj: i32 = cast::<i32>(p[j])
                        if (cj == 34) { j = j + 1; i = j; j = n }
                        else {
                            if (cj == 92) { # backslash
                                if (j + 1 < n) { j = j + 2 } else { j = j + 1 }
                            } else { j = j + 1 }
                        }
                    }
                    push_token(tokens, &count, 3, start, i - start)
                } else {
                    # char: 'a' or '\n'
                    if (cast::<i32>(c) == 39) {
                        let start: i32 = i
                        let j: i32 = i + 1
                        if (j < n) {
                            if (cast::<i32>(p[j]) == 92) {
                                j = j + 2
                                if (j < n) { if (cast::<i32>(p[j - 1]) == 120) { j = j + 2 } }
                            } else {
                                j = j + 1
                            }
                        }
                        if (j < n) { if (cast::<i32>(p[j]) == 39) { j = j + 1 } }
                        i = j
                        push_token(tokens, &count, 4, start, i - start)
                    } else {
                        # ident
                        if (is_alpha(c)) {
                            let start: i32 = i
                            let j: i32 = i + 1
                            while (j < n) {
                                if (is_alpha(p[j])) { j = j + 1 }
                                else {
                                    if (is_digit(p[j])) { j = j + 1 } else { i = j; j = n }
                                }
                            }
                            if (i == start) { i = n }
                            push_token(tokens, &count, 1, start, i - start)
                        } else {
                            # number
                            if (is_digit(c)) {
                                let start: i32 = i
                                let j: i32 = i + 1
                                while (j < n) {
                                    if (is_digit(p[j])) { j = j + 1 } else { i = j; j = n }
                                }
                                # float .digits
                                if (i + 1 < n) {
                                    if (cast::<i32>(p[i]) == 46) {
                                        if (is_digit(p[i + 1])) {
                                            i = i + 1
                                            let k: i32 = i
                                            while (k < n) {
                                                if (is_digit(p[k])) { k = k + 1 } else { i = k; k = n }
                                            }
                                        }
                                    }
                                }
                                push_token(tokens, &count, 2, start, i - start)
                            } else {
                                # operator/punct: single char
                                push_token(tokens, &count, 5, i, 1)
                                i = i + 1
                            }
                        }
                    }
                }
            }
        }
    }

    push_token(tokens, &count, 0, n, 0)
    print("Stage3 tokens:")
    print(count)

    # dump first 20 tokens (kind, start, len)
    let k: i32 = 0
    while (k < count) {
        if (k > 19) { k = count } else {
            let tp: *Token = ptr_offset::<Token>(tokens, k)
            print((*tp).kind)
            print((*tp).start)
            print((*tp).len)
            k = k + 1
        }
    }

    free(raw)
    return 0
}


