
# Stage 5: Self-Hosted Compiler (Single File)
# Includes: Helpers, AST, Lexer, Parser, CodeGen

# --- Helpers ---

fn is_alpha(c: u8) -> bool {
    let x: i32 = cast::<i32>(c);
    if (x > 64) { if (x < 91) { return true; } }     # A-Z
    if (x > 96) { if (x < 123) { return true; } }    # a-z
    if (x == 95) { return true; }                    # _
    return false;
}

fn is_digit(c: u8) -> bool {
    let x: i32 = cast::<i32>(c);
    if (x > 47) { if (x < 58) { return true; } }
    return false;
}

fn is_space(c: u8) -> bool {
    let x: i32 = cast::<i32>(c);
    if (x == 32) { return true; }  # space
    if (x == 9) { return true; }   # \t
    if (x == 10) { return true; }  # \n
    if (x == 13) { return true; }  # \r
    return false;
}

fn strlen(s: string) -> i32 {
    let p: u8* = cast::<u8*>(s);
    let i: i32 = 0;
    while (true) {
        let c: u8 = p[i];
        if (cast::<i32>(c) == 0) { return i; }
        i = i + 1;
    }
    return 0;
}



fn streq(a: string, b: string) -> bool {
    let pa: u8* = cast::<u8*>(a);
    let pb: u8* = cast::<u8*>(b);
    let i: i32 = 0;
    while (true) {
        let ca: u8 = pa[i];
        let cb: u8 = pb[i];
        if (cast::<i32>(ca) == 0) {
            if (cast::<i32>(cb) == 0) { return true; }
            return false;
        }
        if (cast::<i32>(cb) == 0) { return false; }
        if (cast::<i32>(ca) != cast::<i32>(cb)) { return false; }
        i = i + 1;
    }
    return true;
}

fn ptr_offset<T>(ptr: *T, offset: i32) -> *T {
    # Simple pointer arithmetic
    let addr: u64 = cast::<u64>(ptr);
    # offset is in elements, so multiply by sizeof
    let byte_offset: u64 = cast::<u64>(offset) * cast::<u64>(sizeof::<T>());
    return cast::<*T>(addr + byte_offset);
}

struct Buffer<T> {
    ptr: *T,
    len: i32,
    cap: i32
}

# --- Arena Allocator ---

struct Arena {
    chunk: u8*,
    offset: i32,
    capacity: i32
}

fn arena_init(size: i32) -> Arena {
    let chunk: u8* = malloc(size);
    return Arena(chunk, 0, size);
}

fn arena_with_new_offset(old: Arena, new_offset: i32) -> Arena {
    return Arena(old.chunk, new_offset, old.capacity);
}

fn arena_alloc(a: *Arena, size: i32) -> u8* {
    let off: i32 = (*a).offset;
    if (off + size > (*a).capacity) {
        panic("Arena out of memory");
    }
    let ptr: u8* = ptr_offset::<u8>((*a).chunk, off);
    # Instead of (*a).offset = off + size, we recreate the Arena
    let new_arena: Arena = arena_with_new_offset(*a, off + size);
    *a = new_arena;
    return ptr;
}

# --- AST Definitions ---

enum Expr {
    Int(i32),
    Str(string),
    Var(string),
    Binary(i32, *Expr, *Expr),  # op_kind, left, right
    Cast(string, *Expr),        # type, val
    Sizeof(string),             # type
    Member(string, string),     # obj_name, member_name
    Call(string, SliceExpr)     # func_name, args
}

struct SliceExpr {
    ptr: *Expr,
    len: i32
}

struct SliceStmt {
    ptr: *Stmt,
    len: i32
}

struct MatchArm {
    variant_name: string,
    bound_var: string, # empty if none
    body: SliceStmt
}

struct SliceMatchArm {
    ptr: *MatchArm,
    len: i32
}

enum Stmt {
    Return(Expr),
    Print(Expr),
    Let(string, string, Expr),   # name, type, init_expr
    Assign(string, Expr),        # name, val
    If(Expr, SliceStmt),         # cond, body (simple if)
    While(Expr, SliceStmt),      # cond, body
    Match(Expr, SliceMatchArm),  # val, arms
    For(string, Expr, Expr, SliceStmt) # var, start, end, body
}

# --- Specialized Slices ---



struct Function {
    name_start: i32,
    name_len: i32,
    body: SliceStmt
}

struct SliceFunction {
    ptr: *Function,
    len: i32
}

struct Field {
    name: string,
    type_name: string
}

struct SliceField {
    ptr: *Field,
    len: i32
}

struct Struct {
    name: string,
    fields: SliceField
}

struct SliceStruct {
    ptr: *Struct,
    len: i32
}

struct Program {
    structs: SliceStruct,
    functions: SliceFunction
}

# --- Lexer ---

struct Token {
    kind: i32,   # 0=eof, 1=ident, 2=number, 3=string, 4=char, 5=op
    start: i32,
    len: i32
}

fn push_token(tokens: *Token, count: *i32, kind: i32, start: i32, len: i32) {
    let idx: i32 = *count;
    tokens[idx] = Token(kind, start, len);
    *count = idx + 1;
}

fn lex_all(p: *u8, n: i32, tokens: *Token, count: *i32) {
    let i: i32 = 0;
    while (i < n) {
        let c: u8 = p[i];
        if (is_space(c)) {
            i = i + 1;
        } else {
            if (cast::<i32>(c) == 35) { # #
                let j: i32 = i + 1;
                while (j < n) {
                    if (cast::<i32>(p[j]) == 10) { i = j; j = n; } else { j = j + 1; }
                }
            } else {
                if (cast::<i32>(c) == 34) { # "
                    let start: i32 = i;
                    let j: i32 = i + 1;
                    while (j < n) {
                        if (cast::<i32>(p[j]) == 34) { j = j + 1; i = j; j = n; }
                        else { j = j + 1; }
                    }
                    push_token(tokens, count, 3, start, i - start);
                } else {
                    if (is_alpha(c)) {
                        let start: i32 = i;
                        let j: i32 = i + 1;
                        while (j < n) {
                            let is_match: bool = false;
                            if (is_alpha(p[j])) { is_match = true; }
                            else { if (is_digit(p[j])) { is_match = true; } }
                            
                            if (is_match) { j = j + 1; } else { i = j; j = n; }
                        }
                        push_token(tokens, count, 1, start, i - start);
                    } else {
                        if (is_digit(c)) {
                            let start: i32 = i;
                            let j: i32 = i + 1;
                            while (j < n) {
                                if (is_digit(p[j])) { j = j + 1; } else { i = j; j = n; }
                            }
                            push_token(tokens, count, 2, start, i - start);
                        } else {
                            push_token(tokens, count, 5, i, 1);
                            i = i + 1;
                        }
                    }
                }
            }
        }
    }
    push_token(tokens, count, 0, n, 0);
}

# --- Parser ---

struct Parser {
    src: *u8,
    tokens: *Token,
    pos: i32,
    count: i32,
    arena: *Arena
}

fn parser_init(src: *u8, tokens: *Token, count: i32, arena: *Arena) -> Parser {
    return Parser(src, tokens, 0, count, arena);
}


# --- Helpers Extensions ---

# --- Helpers Extensions ---

fn itoa(val: i32) -> string {
    if (val == 0) { return "0"; }
    
    let is_neg: bool = false;
    let temp: i32 = val;
    if (val < 0) { 
        is_neg = true; 
        temp = 0 - temp; 
    }
    
    # Count digits
    let len: i32 = 0;
    if (is_neg) { len = 1; }
    
    let it_val: i32 = temp;
    while (it_val > 0) { 
        it_val = it_val / 10; 
        len = len + 1; 
    }
    
    let buf: u8* = malloc(len + 1);
    buf[len] = cast::<u8>(0); # null terminator
    
    let i: i32 = len - 1;
    while (temp > 0) {
        let digit: i32 = temp % 10;
        buf[i] = cast::<u8>(digit + 48);
        temp = temp / 10;
        i = i - 1;
    }
    
    if (is_neg) {
        buf[0] = cast::<u8>(45); # '-'
    }
    
    return cast::<string>(buf);
}

fn parse_int_val(p: *Parser, tok: Token) -> i32 {
    let s: i32 = tok.start;
    let l: i32 = tok.len;
    let res: i32 = 0;
    let i: i32 = 0;
    
    while (i < l) {
        let c: u8 = ptr_offset::<u8>((*p).src, s + i)[0];
        let digit: i32 = cast::<i32>(c) - 48;
        res = res * 10 + digit;
        i = i + 1;
    }
    return res;
}

fn token_to_string(p: *Parser, tok: Token) -> string {
    let s: i32 = tok.start;
    let l: i32 = tok.len;
    
    if (tok.kind == 3) { # String literal
        s = s + 1;
        l = l - 2;
    }
    
    let buf: u8* = malloc(l + 1);
    let i: i32 = 0;
    while (i < l) {
        let c: u8 = ptr_offset::<u8>((*p).src, s + i)[0];
        buf[i] = c;
        i = i + 1;
    }
    buf[l] = cast::<u8>(0);
    return cast::<string>(buf);
}

# --- Parser ---

fn check(p: *Parser, kind: i32) -> bool {
    let tok_ptr: *Token = ptr_offset::<Token>((*p).tokens, (*p).pos);
    return ((*tok_ptr).kind == kind);
}

fn parser_with_pos(old: Parser, new_pos: i32) -> Parser {
    return Parser(old.src, old.tokens, new_pos, old.count, old.arena);
}

fn consume(p: *Parser, kind: i32) -> Token {
    let tok_ptr: *Token = ptr_offset::<Token>((*p).tokens, (*p).pos);
    if ((*tok_ptr).kind == kind) {
        # Instead of (*p).pos = (*p).pos + 1, recreate Parser
        let new_parser: Parser = parser_with_pos(*p, (*p).pos + 1);
        *p = new_parser;
        return *tok_ptr;
    }
    panic("Unexpected token");
    return *tok_ptr;
}

fn parse_primary(p: *Parser) -> Expr {
    let tok_ptr: *Token = ptr_offset::<Token>((*p).tokens, (*p).pos);
    
    if ((*tok_ptr).kind == 2) { # Number
        consume(p, 2);
        let val: i32 = parse_int_val(p, *tok_ptr);
        return Expr::Int(val);
    }
    if ((*tok_ptr).kind == 3) { # String
        consume(p, 3);
        let s: string = token_to_string(p, *tok_ptr);
        return Expr::Str(s);
    }
    if ((*tok_ptr).kind == 1) { # Ident (Var or Cast/Sizeof or Call)
        # Check for cast or sizeof
        let s_start: i32 = (*tok_ptr).start;
        let c: u8 = ptr_offset::<u8>((*p).src, s_start)[0];
        
        # 'c' for cast (99)
        if (cast::<i32>(c) == 99) {
             # Verify it's "cast" (simplified check)
             consume(p, 1);
             consume(p, 5); # :
             consume(p, 5); # :
             consume(p, 5); # <
             let type_tok: Token = consume(p, 1);
             let ty: string = token_to_string(p, type_tok);
             consume(p, 5); # >
             consume(p, 5); # (
             let val: Expr = parse_expr(p);
             let val_ptr: *Expr = cast::<*Expr>(arena_alloc((*p).arena, sizeof::<Expr>()));
             *val_ptr = val;
             consume(p, 5); # )
             return Expr::Cast(ty, val_ptr);
        }
        
        # 's' for sizeof (115)
        if (cast::<i32>(c) == 115) {
             consume(p, 1);
             consume(p, 5); # :
             consume(p, 5); # :
             consume(p, 5); # <
             let type_tok: Token = consume(p, 1);
             let ty: string = token_to_string(p, type_tok);
             consume(p, 5); # >
             consume(p, 5); # (
             consume(p, 5); # )
             return Expr::Sizeof(ty);
        }

        let name_tok: Token = consume(p, 1);
        let name: string = token_to_string(p, name_tok);
        
        # Check for '(' for Call
        let nt: *Token = ptr_offset::<Token>((*p).tokens, (*p).pos);
        let nt_c: u8 = ptr_offset::<u8>((*p).src, (*nt).start)[0];
        if (cast::<i32>(nt_c) == 40) { # (
            consume(p, 5);
            let args_ptr: *Expr = cast::<*Expr>(arena_alloc((*p).arena, 10 * sizeof::<Expr>()));
            let args_cnt: i32 = 0;
            while (true) {
                let cur_t: *Token = ptr_offset::<Token>((*p).tokens, (*p).pos);
                let cur_c: u8 = ptr_offset::<u8>((*p).src, (*cur_t).start)[0];
                if (cast::<i32>(cur_c) == 41) { break; } # )
                
                args_ptr[args_cnt] = parse_expr(p);
                args_cnt = args_cnt + 1;
                
                # Comma
                let nxt_t: *Token = ptr_offset::<Token>((*p).tokens, (*p).pos);
                let nxt_c: u8 = ptr_offset::<u8>((*p).src, (*nxt_t).start)[0];
                if (cast::<i32>(nxt_c) == 44) { consume(p, 5); }
            }
            consume(p, 5); # )
            return Expr::Call(name, SliceExpr(args_ptr, args_cnt));
        }

        return Expr::Var(name);
    }
    panic("Expected primary expression");
    return Expr::Int(0);
}

fn parse_expr(p: *Parser) -> Expr {
    # Simple binary parsing (left-associative, only one level for now or specific ops)
    # LHS
    let lhs_val: Expr = parse_primary(p);
    let lhs_ptr: *Expr = cast::<*Expr>(arena_alloc((*p).arena, sizeof::<Expr>()));
    *lhs_ptr = lhs_val;
    
    # Check for Op
    let tok_ptr: *Token = ptr_offset::<Token>((*p).tokens, (*p).pos);
    if ((*tok_ptr).kind == 5) { # Op
        # Check specific ops: +, -, *, / ( ==, >, < later)
        # We need to peek content.
        let s: i32 = (*tok_ptr).start;
        let c: u8 = ptr_offset::<u8>((*p).src, s)[0];
        let op_code: i32 = cast::<i32>(c);
        
        # +, -, *, /, %, >, <, = (wait, = is assign, == is eq)
        if (op_code == 43) { # +
            consume(p, 5); 
            let rhs_val: Expr = parse_primary(p); 
            let rhs_ptr: *Expr = cast::<*Expr>(arena_alloc((*p).arena, sizeof::<Expr>()));
            *rhs_ptr = rhs_val;
            return Expr::Binary(43, lhs_ptr, rhs_ptr);
        }
        if (op_code == 45) { # -
            consume(p, 5); 
            let rhs_val: Expr = parse_primary(p); 
            let rhs_ptr: *Expr = cast::<*Expr>(arena_alloc((*p).arena, sizeof::<Expr>()));
            *rhs_ptr = rhs_val;
            return Expr::Binary(45, lhs_ptr, rhs_ptr);
        }
        if (op_code == 62) { # >
            consume(p, 5); 
            let rhs_val: Expr = parse_primary(p); 
            let rhs_ptr: *Expr = cast::<*Expr>(arena_alloc((*p).arena, sizeof::<Expr>()));
            *rhs_ptr = rhs_val;
            return Expr::Binary(62, lhs_ptr, rhs_ptr);
        }
    }
    
    # Return value from pointer (copy/move out?)
    # We moved lhs_val to *lhs_ptr.
    # We need to return an Expr.
    # Dereferencing *lhs_ptr copies if Copy, or Moves if not.
    # Can we move out of pointer? Semantic Analyzer says no.
    # BUT, we are in non-branching case here.
    # Actually, we can just return lhs_val?
    # But lhs_val was moved to *lhs_ptr.
    # So lhs_val is moved.
    # We need to extract it back?
    # Or just NOT allocate if not needed?
    # But we don't know if we need it until we check op.
    
    # Workaround:
    # 1. Parse lhs. Don't move yet.
    # 2. Check op.
    # 3. If op, THEN alloc lhs_ptr, move lhs, parse rhs...
    # 4. If no op, return lhs.
    
    # This avoids moving lhs if we return it directly.
    return *lhs_ptr; 
    # Semantic Analyzer might complain about moving from pointer *lhs_ptr.
    # We need "unsafe" or similar? Or `ptr::read` intrinsic?
    # For now, let's use the branching alloc strategy.
}


fn parse_stmts(p: *Parser) -> SliceStmt {
    let stmts_ptr: *Stmt = cast::<*Stmt>(arena_alloc((*p).arena, 20 * sizeof::<Stmt>()));
    let cnt: i32 = 0;
    
    let running: bool = true;
    while (running) {
        let tok_ptr: *Token = ptr_offset::<Token>((*p).tokens, (*p).pos);
        if ((*tok_ptr).kind == 0) { running = false; } # EOF
        
        if (running) {
            # Check for '}'
            let s: i32 = (*tok_ptr).start;
            let c: u8 = ptr_offset::<u8>((*p).src, s)[0];
            if (cast::<i32>(c) == 125) { running = false; }
            
            if (running) {
                let stmt: Stmt = parse_stmt(p);
                stmts_ptr[cnt] = stmt;
                cnt = cnt + 1;
            }
        }
    }
    return SliceStmt(stmts_ptr, cnt);
}

fn parse_stmt(p: *Parser) -> Stmt {
    let tok_ptr: *Token = ptr_offset::<Token>((*p).tokens, (*p).pos);
    
    if ((*tok_ptr).kind == 1) { 
        # Check Identifier content for keywords
        let s_start: i32 = (*tok_ptr).start;
        let c: u8 = ptr_offset::<u8>((*p).src, s_start)[0];
        let c2: u8 = ptr_offset::<u8>((*p).src, s_start + 1)[0];
        
        # 'p' for print (112)
        if (cast::<i32>(c) == 112) { 
            consume(p, 1);
            consume(p, 5); # (
            let e: Expr = parse_expr(p);
            consume(p, 5); # )
            # Semicolon
            let next_t: *Token = ptr_offset::<Token>((*p).tokens, (*p).pos);
            if ((*next_t).kind == 5) { consume(p, 5); }
            return Stmt::Print(e);
        }
        
        # 'r' for return (114)
        if (cast::<i32>(c) == 114) {
             consume(p, 1);
             let e: Expr = parse_expr(p);
             return Stmt::Return(e);
        }
        
        # 'l' for let (108)
        if (cast::<i32>(c) == 108) {
            consume(p, 1); # let
            let name_tok: Token = consume(p, 1); # name
            let name: string = token_to_string(p, name_tok);
            
            consume(p, 5); # :
            let type_tok: Token = consume(p, 1); # type
            let ty: string = token_to_string(p, type_tok);
            
            # Check =
            let eq_tok: *Token = ptr_offset::<Token>((*p).tokens, (*p).pos);
            # We need to check if op is '=' (61)
            let eq_op_c: u8 = ptr_offset::<u8>((*p).src, (*eq_tok).start)[0];
            if (cast::<i32>(eq_op_c) == 61) {
                consume(p, 5); # =
                let init: Expr = parse_expr(p);
                 # Semicolon
                let next_t: *Token = ptr_offset::<Token>((*p).tokens, (*p).pos);
                if ((*next_t).kind == 5) { consume(p, 5); }
                return Stmt::Let(name, ty, init);
            }
            # Else? default init?
            panic("Let requires init");
        }
        
        # 'i' for if (105)
        if (cast::<i32>(c) == 105) {
             if (cast::<i32>(c2) == 102) { # if
                 consume(p, 1);
                 let cond: Expr = parse_expr(p);
                 consume(p, 5); # {
                 let body: SliceStmt = parse_stmts(p);
                 consume(p, 5); # }
                 return Stmt::If(cond, body);
             }
        }
        
        # 'w' for while (119)
        if (cast::<i32>(c) == 119) {
             consume(p, 1);
             let cond: Expr = parse_expr(p);
             consume(p, 5); # {
             let body: SliceStmt = parse_stmts(p);
             consume(p, 5); # }
             return Stmt::While(cond, body);
        }
        
        # 'f' for for (102)
        if (cast::<i32>(c) == 102) {
             if (cast::<i32>(c2) == 111) { # for
                 consume(p, 1);
                 let var_tok: Token = consume(p, 1);
                 let var_name: string = token_to_string(p, var_tok);
                 
                 consume(p, 1); # in
                 
                 let start_expr: Expr = parse_expr(p);
                 consume(p, 5); # .
                 consume(p, 5); # .
                 let end_expr: Expr = parse_expr(p);
                 
                 consume(p, 5); # {
                 let body: SliceStmt = parse_stmts(p);
                 consume(p, 5); # }
                 
                 return Stmt::For(var_name, start_expr, end_expr, body);
             }
        }
        
        # 'm' for match (109)
        if (cast::<i32>(c) == 109) {
             consume(p, 1);
             let val: Expr = parse_expr(p);
             consume(p, 5); # {
             
             let arms_ptr: *MatchArm = cast::<*MatchArm>(arena_alloc((*p).arena, 10 * sizeof::<MatchArm>()));
             let arms_cnt: i32 = 0;
             
             while (true) {
                 let t: *Token = ptr_offset::<Token>((*p).tokens, (*p).pos);
                 let first_c: u8 = ptr_offset::<u8>((*p).src, (*t).start)[0];
                 if (cast::<i32>(first_c) == 125) { break; } # }
                 
                 let variant_tok: Token = consume(p, 1);
                 let variant_name: string = token_to_string(p, variant_tok);
                 
                 let bound_var: string = "";
                 let nt: *Token = ptr_offset::<Token>((*p).tokens, (*p).pos);
                 let nt_c: u8 = ptr_offset::<u8>((*p).src, (*nt).start)[0];
                 if (cast::<i32>(nt_c) == 40) { # (
                     consume(p, 5);
                     let bv_tok: Token = consume(p, 1);
                     bound_var = token_to_string(p, bv_tok);
                     consume(p, 5); # )
                 }
                 
                 consume(p, 5); # =
                 consume(p, 5); # >
                 consume(p, 5); # {
                 let body: SliceStmt = parse_stmts(p);
                 consume(p, 5); # }
                 
                 arms_ptr[arms_cnt] = MatchArm(variant_name, bound_var, body);
                 arms_cnt = arms_cnt + 1;
             }
             consume(p, 5); # }
             return Stmt::Match(val, SliceMatchArm(arms_ptr, arms_cnt));
        }
        
        # Assignment? If it's identifier not keyword.
        # Assume assignment if followed by = (checked via peek)
        # Or simple var usage? Statement can be expression?
        # For now, restrict to Assignment: name = expr;
        
        # Note: 'name' is already peeked as *tok_ptr.
        # Try to parse assignment.
        let name_tok: Token = consume(p, 1);
        let name: string = token_to_string(p, name_tok);
        
        let op_tok: *Token = ptr_offset::<Token>((*p).tokens, (*p).pos);
        if ((*op_tok).kind == 5) {
            let op_c: u8 = ptr_offset::<u8>((*p).src, (*op_tok).start)[0];
             if (cast::<i32>(op_c) == 61) { # =
                 consume(p, 5);
                 let val: Expr = parse_expr(p);
                 # Semicolon
                 let next_t: *Token = ptr_offset::<Token>((*p).tokens, (*p).pos);
                 if ((*next_t).kind == 5) { consume(p, 5); }
                 return Stmt::Assign(name, val);
             }
        }
        
        # If not assignment, maybe function call? Not supported as stmt yet in this stage5.
        panic("Unknown statement or assignment");
    }
    
    # panic("Unknown statement");
    consume(p, (*tok_ptr).kind);
    return Stmt::Print(Expr::Int(0));
}

fn parse_fn(p: *Parser) -> Function {
    # fn name() { ... }
    consume(p, 1); # fn (kw)
    let name_tok: Token = consume(p, 1); # name
    consume(p, 5); # (
    consume(p, 5); # )
    
    # Check for optional return type: -> type
    let tok_ptr_ret: *Token = ptr_offset::<Token>((*p).tokens, (*p).pos);
    let s_ret: i32 = (*tok_ptr_ret).start;
    let c_ret: u8 = ptr_offset::<u8>((*p).src, s_ret)[0];
    # '-' is 45, check if we have '->'
    if (cast::<i32>(c_ret) == 45) {
        consume(p, 5); # ->
        consume(p, 1); # type name (i32, etc.)
    }
    
    consume(p, 5); # {
    
    # Body
    let stmts_ptr: *Stmt = cast::<*Stmt>(arena_alloc((*p).arena, 20 * sizeof::<Stmt>()));
    let cnt: i32 = 0;
    
    let running: bool = true;
    while (running) {
        let tok_ptr: *Token = ptr_offset::<Token>((*p).tokens, (*p).pos);
        if ((*tok_ptr).kind == 0) { running = false; } # EOF
        
        if (running) {
            # Check for '}'
            let s: i32 = (*tok_ptr).start;
            let c: u8 = ptr_offset::<u8>((*p).src, s)[0];
            if (cast::<i32>(c) == 125) { running = false; }
            
            if (running) {
                let stmt: Stmt = parse_stmt(p);
                stmts_ptr[cnt] = stmt;
                cnt = cnt + 1;
            }
        }
    }
    consume(p, 5); # }
    
    return Function(name_tok.start, name_tok.len, SliceStmt(stmts_ptr, cnt));
}

fn parse_struct(p: *Parser) -> Struct {
    consume(p, 1); # struct
    let name_tok: Token = consume(p, 1);
    let name: string = token_to_string(p, name_tok);
    
    consume(p, 5); # {
    
    let fields_ptr: *Field = cast::<*Field>(arena_alloc((*p).arena, 20 * sizeof::<Field>()));
    let cnt: i32 = 0;
    
    while (true) {
        let t: *Token = ptr_offset::<Token>((*p).tokens, (*p).pos);
        let first_c: u8 = ptr_offset::<u8>((*p).src, (*t).start)[0];
        if (cast::<i32>(first_c) == 125) { break; } # }
        
        let f_name_tok: Token = consume(p, 1);
        let f_name: string = token_to_string(p, f_name_tok);
        
        consume(p, 5); # :
        
        let f_type_tok: Token = consume(p, 1);
        let f_type: string = token_to_string(p, f_type_tok);
        
        # Optional comma
        let nt: *Token = ptr_offset::<Token>((*p).tokens, (*p).pos);
        let nt_c: u8 = ptr_offset::<u8>((*p).src, (*nt).start)[0];
        if (cast::<i32>(nt_c) == 44) { consume(p, 5); }
        
        fields_ptr[cnt] = Field(f_name, f_type);
        cnt = cnt + 1;
    }
    
    consume(p, 5); # }
    return Struct(name, SliceField(fields_ptr, cnt));
}

fn parse_prog(p: *Parser) -> Program {
    let funcs_ptr: *Function = cast::<*Function>(arena_alloc((*p).arena, 20 * sizeof::<Function>()));
    let f_cnt: i32 = 0;
    
    let structs_ptr: *Struct = cast::<*Struct>(arena_alloc((*p).arena, 20 * sizeof::<Struct>()));
    let s_cnt: i32 = 0;
    
    while ((*p).pos < (*p).count - 1) { # -1 for EOF check
        let t: *Token = ptr_offset::<Token>((*p).tokens, (*p).pos);
        let s_start: i32 = (*t).start;
        let c: u8 = ptr_offset::<u8>((*p).src, s_start)[0];
        let c2: u8 = ptr_offset::<u8>((*p).src, s_start + 1)[0];
        
        # 'f' for fn (102)
        if (cast::<i32>(c) == 102 and cast::<i32>(c2) == 110) {
            funcs_ptr[f_cnt] = parse_fn(p);
            f_cnt = f_cnt + 1;
        } else {
            # 's' for struct (115)
            if (cast::<i32>(c) == 115) {
                structs_ptr[s_cnt] = parse_struct(p);
                s_cnt = s_cnt + 1;
            } else {
                # Skip unknown top-level
                consume(p, (*t).kind);
            }
        }
    }
    
    return Program(SliceStruct(structs_ptr, s_cnt), SliceFunction(funcs_ptr, f_cnt));
}

# --- CodeGen Utils ---

struct Symbol {
    name: string,
    reg: string
}

struct SymTable {
    syms: *Symbol,
    count: i32
}

struct Context {
    out: string,
    syms: *SymTable,
    arena: *Arena
}

fn streq(a: string, b: string) -> bool {
    let la: i32 = strlen(a);
    let lb: i32 = strlen(b);
    if (la != lb) { return false; }
    let i: i32 = 0;
    while (i < la) {
        let ca: u8 = ptr_offset::<u8>(a, i)[0];
        let cb: u8 = ptr_offset::<u8>(b, i)[0];
        if (cast::<i32>(ca) != cast::<i32>(cb)) { return false; }
        i = i + 1;
    }
    return true;
}

fn st_find(st: *SymTable, name: string) -> string {
    let i: i32 = 0;
    while (i < st.count) {
        let s: Symbol = st.syms[i];
        if (streq(s.name, name)) { return s.reg; }
        i = i + 1;
    }
    return "";
}

fn st_insert(st: *SymTable, name: string, reg: string) {
    let idx: i32 = st.count;
    st.syms[idx] = Symbol(name, reg);
    st.count = idx + 1;
}

fn str_cat(arena: *Arena, a: string, b: string) -> string {
    let la: i32 = strlen(a);
    let lb: i32 = strlen(b);
    let s: u8* = arena_alloc(arena, la + lb + 1);
    let i: i32 = 0;
    while (i < la) {
        ptr_offset::<u8>(s, i)[0] = ptr_offset::<u8>(a, i)[0];
        i = i + 1;
    }
    let j: i32 = 0;
    while (j < lb) {
        ptr_offset::<u8>(s, la + j)[0] = ptr_offset::<u8>(b, j)[0];
        j = j + 1;
    }
    ptr_offset::<u8>(s, la + lb)[0] = cast::<u8>(0);
    return cast::<string>(s);
}

fn next_reg(ctx: *Context) -> string {
    # Without tmp_count tracking, just return a generic temporary
    # This is a limitation but allows bootstrap to work
    return "tmp";
}

fn emit_expr(e: Expr, ctx: *Context) -> string {
    match e {
        Int(v) => { return itoa(v); }
        Str(v) => { return "0"; } # Placeholder
        Var(name) => {
            let reg: string = st_find(ctx.syms, name);
            if (streq(reg, "")) { return "0"; }
            
            let out_reg_id: string = next_reg(ctx);
            let out_reg: string = str_cat(ctx.arena, "%", out_reg_id);
            
            fs::append_file(ctx.out, "  ", 2);
            fs::append_file(ctx.out, out_reg, strlen(out_reg));
            fs::append_file(ctx.out, " = load i32, i32* %", 19);
            fs::append_file(ctx.out, reg, strlen(reg));
            fs::append_file(ctx.out, "\n", 1);
            
            return out_reg;
        }
        Binary(op, l, r) => {
             let l_val: string = emit_expr(*l, ctx);
             let r_val: string = emit_expr(*r, ctx);
             
             let op_str: string = "add";
             if (op == 43) { op_str = "add"; }
             if (op == 45) { op_str = "sub"; }
             if (op == 62) { op_str = "icmp sgt"; }
             
             let out_reg_id: string = next_reg(ctx);
             let out_reg: string = str_cat(ctx.arena, "%", out_reg_id);
             
             fs::append_file(ctx.out, "  ", 2);
             fs::append_file(ctx.out, out_reg, strlen(out_reg));
             fs::append_file(ctx.out, " = ", 3);
             fs::append_file(ctx.out, op_str, strlen(op_str));
             fs::append_file(ctx.out, " i32 ", 5);
             fs::append_file(ctx.out, l_val, strlen(l_val));
             fs::append_file(ctx.out, ", ", 2);
             fs::append_file(ctx.out, r_val, strlen(r_val));
             fs::append_file(ctx.out, "\n", 1);
             return out_reg;
        }
    }
    return "0";
}

fn emit_stmt(s: Stmt, ctx: *Context) {
    match s {
        Print(e) => {
             # Special case for Str (Global) or Int (Simple)
             # But general case: evaluate expr, print as int
             match e {
                 Str(v) => {
                     # Handled in main loop for globals? 
                     # Or we can do inline string?
                     # For now, let main loop handle strings in Pass 2? 
                     # Or implement here.
                     # Let's just emit "Scanning..." message or similar?
                     # Ignoring Str print inside here for now
                 }
                 Int(v) => {
                     let val: string = emit_expr(Expr::Int(v), ctx);
                     fs::append_file(ctx.out, "  %p", 4);
                     let tmp_id: string = next_reg(ctx);
                     fs::append_file(ctx.out, tmp_id, strlen(tmp_id)); 
                     fs::append_file(ctx.out, " = call i32 (i8*, ...) @printf(i8* getelementptr ([4 x i8], [4 x i8]* @fmt_int, i32 0, i32 0), i32 ", 109);
                     fs::append_file(ctx.out, val, strlen(val));
                     fs::append_file(ctx.out, ")\n", 2);
                 }
                 Var(n) => {
                     let val: string = emit_expr(Expr::Var(n), ctx);
                     fs::append_file(ctx.out, "  call i32 (i8*, ...) @printf(i8* getelementptr ([4 x i8], [4 x i8]* @fmt_int, i32 0, i32 0), i32 ", 107);
                     fs::append_file(ctx.out, val, strlen(val));
                     fs::append_file(ctx.out, ")\n", 2);
                 }
                 Binary(o, l, r) => {
                     let val: string = emit_expr(Expr::Binary(o, l, r), ctx);
                     fs::append_file(ctx.out, "  call i32 (i8*, ...) @printf(i8* getelementptr ([4 x i8], [4 x i8]* @fmt_int, i32 0, i32 0), i32 ", 107);
                     fs::append_file(ctx.out, val, strlen(val));
                     fs::append_file(ctx.out, ")\n", 2);
                 }
             }
        }
        Return(e) => {
            let val: string = emit_expr(e, ctx);
            fs::append_file(ctx.out, "  ret i32 ", 10);
            fs::append_file(ctx.out, val, strlen(val));
            fs::append_file(ctx.out, "\n", 1);
        }
        Let(name, ty, init) => {
            fs::append_file(ctx.out, "  %", 3);
            fs::append_file(ctx.out, name, strlen(name));
            fs::append_file(ctx.out, " = alloca i32\n", 14); # Assume i32
            
            st_insert(ctx.syms, name, name);
            
            let val: string = emit_expr(init, ctx);
            fs::append_file(ctx.out, "  store i32 ", 12);
            fs::append_file(ctx.out, val, strlen(val));
            fs::append_file(ctx.out, ", i32* %", 8);
            fs::append_file(ctx.out, name, strlen(name));
            fs::append_file(ctx.out, "\n", 1);
        }
        Assign(name, val) => {
            let reg: string = st_find(ctx.syms, name);
            if (streq(reg, "")) { return; }
            let v: string = emit_expr(val, ctx);
            fs::append_file(ctx.out, "  store i32 ", 12);
            fs::append_file(ctx.out, v, strlen(v));
            fs::append_file(ctx.out, ", i32* %", 8);
            fs::append_file(ctx.out, reg, strlen(reg));
            fs::append_file(ctx.out, "\n", 1);
        }
        If(cond, body) => {
             let c_val: string = emit_expr(cond, ctx);
             
             let l_then_id: string = next_reg(ctx);
             let l_end_id: string = next_reg(ctx);
             
             # Compare c_val != 0?
             let c_bool_id: string = next_reg(ctx);
             let c_bool: string = str_cat(ctx.arena, "%", c_bool_id);
             fs::append_file(ctx.out, "  ", 2);
             fs::append_file(ctx.out, c_bool, strlen(c_bool));
             fs::append_file(ctx.out, " = icmp ne i32 ", 15);
             fs::append_file(ctx.out, c_val, strlen(c_val));
             fs::append_file(ctx.out, ", 0\n", 4);
             
             fs::append_file(ctx.out, "  br i1 ", 8);
             fs::append_file(ctx.out, c_bool, strlen(c_bool));
             fs::append_file(ctx.out, ", label %L", 10);
             fs::append_file(ctx.out, l_then_id, strlen(l_then_id));
             fs::append_file(ctx.out, ", label %L", 10);
             fs::append_file(ctx.out, l_end_id, strlen(l_end_id));
             fs::append_file(ctx.out, "\n", 1);
             
             # Then Block
             fs::append_file(ctx.out, "L", 1);
             fs::append_file(ctx.out, l_then_id, strlen(l_then_id));
             fs::append_file(ctx.out, ":\n", 2);
             
             let k: i32 = 0;
             while (k < body.len) {
                 emit_stmt(body.ptr[k], ctx);
                 k = k + 1;
             }
             fs::append_file(ctx.out, "  br label %L", 13);
             fs::append_file(ctx.out, l_end_id, strlen(l_end_id));
             fs::append_file(ctx.out, "\n", 1);
             
             # End Block
             fs::append_file(ctx.out, "L", 1);
             fs::append_file(ctx.out, l_end_id, strlen(l_end_id));
             fs::append_file(ctx.out, ":\n", 2);
        }
        While(cond, body) => {
             let l_head_id: string = next_reg(ctx);
             let l_body_id: string = next_reg(ctx);
             let l_end_id: string = next_reg(ctx);
             
             fs::append_file(ctx.out, "  br label %L", 13);
             fs::append_file(ctx.out, l_head_id, strlen(l_head_id));
             fs::append_file(ctx.out, "\n", 1);
             
             fs::append_file(ctx.out, "L", 1);
             fs::append_file(ctx.out, l_head_id, strlen(l_head_id));
             fs::append_file(ctx.out, ":\n", 2);
             
             let c_val: string = emit_expr(cond, ctx);
             let c_bool_id: string = next_reg(ctx);
             let c_bool: string = str_cat(ctx.arena, "%", c_bool_id);
             fs::append_file(ctx.out, "  ", 2);
             fs::append_file(ctx.out, c_bool, strlen(c_bool));
             fs::append_file(ctx.out, " = icmp ne i32 ", 15);
             fs::append_file(ctx.out, c_val, strlen(c_val));
             fs::append_file(ctx.out, ", 0\n", 4);
             
             fs::append_file(ctx.out, "  br i1 ", 8);
             fs::append_file(ctx.out, c_bool, strlen(c_bool));
             fs::append_file(ctx.out, ", label %L", 10);
             fs::append_file(ctx.out, l_body_id, strlen(l_body_id));
             fs::append_file(ctx.out, ", label %L", 10);
             fs::append_file(ctx.out, l_end_id, strlen(l_end_id));
             fs::append_file(ctx.out, "\n", 1);
             
             fs::append_file(ctx.out, "L", 1);
             fs::append_file(ctx.out, l_body_id, strlen(l_body_id));
             fs::append_file(ctx.out, ":\n", 2);
             
             let k: i32 = 0;
             while (k < body.len) {
                 emit_stmt(body.ptr[k], ctx);
                 k = k + 1;
             }
             fs::append_file(ctx.out, "  br label %L", 13);
             fs::append_file(ctx.out, l_head_id, strlen(l_head_id));
             fs::append_file(ctx.out, "\n", 1);
             
             fs::append_file(ctx.out, "L", 1);
             fs::append_file(ctx.out, l_end_id, strlen(l_end_id));
             fs::append_file(ctx.out, ":\n", 2);
        }
    }
}

fn emit_ll(prog: Program) {
    let out: string = "dev/artifacts/output.ll";
    fs::write_file(out, "; ModuleID = 'selfhost'\n", 24);
    fs::append_file(out, "declare i32 @printf(i8*, ...)\n", 30);
    fs::append_file(out, "@fmt_int = private constant [4 x i8] c\"%d\\0A\\00\"\n", 47);
    fs::append_file(out, "@fmt_str = private constant [4 x i8] c\"%s\\0A\\00\"\n", 47);
    
    # Init CodeGen Arena
    let cg_mem: Arena = arena_init(1024 * 1024);
    
    let i: i32 = 0;
    while (i < prog.functions.len) {
        let f: Function = prog.functions.ptr[i];
        
        # Init Symbol Table for each function
        let syms_ptr: *Symbol = cast::<*Symbol>(arena_alloc(&cg_mem, 1024 * 16)); 
        let st: *SymTable = cast::<*SymTable>(arena_alloc(&cg_mem, sizeof::<SymTable>()));
        *st = SymTable(syms_ptr, 0);
        
        let ctx: Context = Context(out, st, &cg_mem);
        
        fs::append_file(out, "define i32 @main() {\nentry:\n", 28);
        
        let j: i32 = 0;
        while (j < f.body.len) {
            emit_stmt(f.body.ptr[j], &ctx);
            j = j + 1;
        }
        
        fs::append_file(out, "  ret i32 0\n}\n", 13);
        i = i + 1;
    }
    
    # Globals handling omitted for now (Print(Str) will be no-op)
    print("Emitted LLVM IR to dev/artifacts/output.ll");
}
# --- Main ---

fn main() -> i32 {
    print("Starting Self-Host Compiler...");
    
    # 1. Read Lexer
    let src_buf: Buffer<u8> = fs::read_file("examples/ultra_simple.nxl");
    
    # 2. Tokenize
    let max_toks: i32 = 1000;
    let tok_bytes: i32 = max_toks * sizeof::<Token>();
    let tokens: *Token = cast::<*Token>(malloc(tok_bytes));
    let count: i32 = 0;
    lex_all(src_buf.ptr, src_buf.len, tokens, &count);
    print("Lexed tokens.");
    
    # 3. Parse
    let mem: Arena = arena_init(1024 * 1024); # 1MB
    let parser: Parser = parser_init(src_buf.ptr, tokens, count, &mem);
    let prog: Program = parse_prog(&parser);
    print("Parsed AST.");
    
    # 4. CodeGen
    emit_ll(prog);
    
    return 0;
}
