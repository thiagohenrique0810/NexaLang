fn strlen(s: string) -> i32 {
    let i: i32 = 0;
    while (true) {
        let c: u8 = s[i];
        if (cast::<i32>(c) == 0) { return i; }
        i = i + 1;
    }
    return 0;
}

fn w(path: string, line: string) {
    fs::write_file(path, line, strlen(line));
}

fn a(path: string, line: string) {
    fs::append_file(path, line, strlen(line));
}

fn main() -> i32 {
    let out: string = "dev/artifacts/selfhost_out.ll";

    # A tiny LLVM IR module generated by NexaLang (selfhost Stage 5).
    w(out, "; ModuleID = \"selfhost\"\n");
    a(out, "target triple = \"unknown-unknown-unknown\"\n\n");
    a(out, "declare i32 @printf(i8*, ...)\n\n");
    a(out, "@fmt = private constant [4 x i8] c\"%d\\0A\\00\"\n\n");
    a(out, "define i32 @main() {\n");
    a(out, "entry:\n");
    a(out, "  %fmtp = getelementptr [4 x i8], [4 x i8]* @fmt, i32 0, i32 0\n");
    a(out, "  %call = call i32 (i8*, ...) @printf(i8* %fmtp, i32 123)\n");
    a(out, "  ret i32 0\n");
    a(out, "}\n");

    print("wrote dev/artifacts/selfhost_out.ll");
    return 0;
}



