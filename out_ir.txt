; ModuleID = "nexalang_module"
target triple = "unknown-unknown-unknown"
target datalayout = ""

%"std_vec_VecIterator" = type opaque
%"std_vec_Vec" = type opaque
%"std_map_Entry" = type opaque
%"std_map_HashMap" = type opaque
%"std_map_Entry<i32,i32>" = type {i32, i32}
%"std_vec_Vec<std_map_Entry<i32,i32>>" = type {%"std_map_Entry<i32,i32>"*, i32, i32}
%"std_map_HashMap<i32,i32>" = type {%"std_vec_Vec<std_map_Entry<i32,i32>>"}
declare i32 @"printf"(i8* %".1", ...)

declare void @"exit"(i32 %".1")

declare i8* @"malloc"(i32 %".1")

declare void @"free"(i8* %".1")

declare i8* @"realloc"(i8* %".1", i32 %".2")

declare void @"llvm.memcpy.p0i8.p0i8.i32"(i8* %".1", i8* %".2", i32 %".3", i1 %".4")

declare i8* @"fopen"(i8* %".1", i8* %".2")

declare i32 @"fseek"(i8* %".1", i64 %".2", i32 %".3")

declare i64 @"ftell"(i8* %".1")

declare i64 @"fread"(i8* %".1", i64 %".2", i64 %".3", i8* %".4")

declare i64 @"fwrite"(i8* %".1", i64 %".2", i64 %".3", i8* %".4")

declare i32 @"fclose"(i8* %".1")

@"__gpu_global_id" = internal global i32 0
define {i8*, i32, i32} @"Arena_new"()
{
entry:
  %".2" = call i8* @"malloc"(i32 4096)
  %".3" = insertvalue {i8*, i32, i32} undef, i8* %".2", 0
  %".4" = insertvalue {i8*, i32, i32} %".3", i32 0, 1
  %".5" = insertvalue {i8*, i32, i32} %".4", i32 4096, 2
  ret {i8*, i32, i32} %".5"
}

define void @"Arena_drop"({i8*, i32, i32} %".1")
{
entry:
  %".3" = extractvalue {i8*, i32, i32} %".1", 0
  call void @"free"(i8* %".3")
  ret void
}

define i8* @"Arena_alloc"({i8*, i32, i32}* %".1", i32 %".2")
{
entry:
  %".4" = getelementptr {i8*, i32, i32}, {i8*, i32, i32}* %".1", i32 0, i32 0
  %".5" = getelementptr {i8*, i32, i32}, {i8*, i32, i32}* %".1", i32 0, i32 1
  %".6" = getelementptr {i8*, i32, i32}, {i8*, i32, i32}* %".1", i32 0, i32 2
  %".7" = load i8*, i8** %".4"
  %".8" = load i32, i32* %".5"
  %".9" = load i32, i32* %".6"
  %".10" = add i32 %".8", %".2"
  %".11" = icmp ugt i32 %".10", %".9"
  br i1 %".11", label %"entry.if", label %"entry.endif"
entry.if:
  call void @"exit"(i32 1)
  br label %"entry.endif"
entry.endif:
  %".15" = ptrtoint i8* %".7" to i64
  %".16" = zext i32 %".8" to i64
  %".17" = add i64 %".15", %".16"
  %".18" = inttoptr i64 %".17" to i8*
  store i32 %".10", i32* %".5"
  ret i8* %".18"
}

declare i8 @"std_option_Option_unwrap"({i32, [256 x i8]} %".1")

declare {i32, [256 x i8]} @"std_vec_VecIterator_next"(%"std_vec_VecIterator"* %".1")

declare %"std_vec_Vec" @"std_vec_Vec_new"()

declare void @"std_vec_Vec_push"(%"std_vec_Vec"* %".1", i8 %".2")

declare %"std_vec_VecIterator" @"std_vec_Vec_iter"(%"std_vec_Vec"* %".1")

declare i32 @"std_vec_Vec_len"(%"std_vec_Vec"* %".1")

declare void @"std_vec_Vec_clear"(%"std_vec_Vec"* %".1")

declare {i32, [256 x i8]} @"std_vec_Vec_get"(%"std_vec_Vec"* %".1", i32 %".2")

declare void @"std_vec_Vec_set"(%"std_vec_Vec"* %".1", i32 %".2", i8 %".3")

declare {i32, [256 x i8]} @"std_vec_Vec_pop"(%"std_vec_Vec"* %".1")

declare i1 @"std_result_Result_is_ok"({i32, [256 x i8]}* %".1")

declare i1 @"std_result_Result_is_err"({i32, [256 x i8]}* %".1")

declare i8 @"std_result_Result_unwrap"({i32, [256 x i8]} %".1")

define i64 @"i32_hash"(i32* %"self")
{
entry:
  %"self.1" = alloca i32*
  store i32* %"self", i32** %"self.1"
  %"self.2" = load i32*, i32** %"self.1"
  %".4" = load i32, i32* %"self.2"
  %".5" = zext i32 %".4" to i64
  ret i64 %".5"
}

define i64 @"string_hash"(i8** %"self")
{
entry:
  %"self.1" = alloca i8**
  store i8** %"self", i8*** %"self.1"
  %"self.2" = load i8**, i8*** %"self.1"
  %".4" = load i8*, i8** %"self.2"
  %"s" = alloca i8*
  store i8* %".4", i8** %"s"
  %"s.1" = load i8*, i8** %"s"
  %"ptr" = alloca i8*
  store i8* %"s.1", i8** %"ptr"
  %"i" = alloca i32
  store i32 0, i32* %"i"
  %"h" = alloca i32
  store i32 5381, i32* %"h"
  br label %"whilecond"
whilecond:
  br i1 1, label %"whileloop", label %"whileend"
whileloop:
  %"i.1" = load i32, i32* %"i"
  %".11" = load i8*, i8** %"ptr"
  %".12" = getelementptr i8, i8* %".11", i32 %"i.1"
  %".13" = load i8, i8* %".12"
  %"c" = alloca i8
  store i8 %".13", i8* %"c"
  %"c.1" = load i8, i8* %"c"
  %".15" = zext i8 %"c.1" to i32
  %"eqtmp" = icmp eq i32 %".15", 0
  br i1 %"eqtmp", label %"then", label %"else"
whileend:
  %"h.2" = load i32, i32* %"h"
  %".23" = zext i32 %"h.2" to i64
  ret i64 %".23"
then:
  br label %"whileend"
else:
  br label %"ifcont"
ifcont:
  %"h.1" = load i32, i32* %"h"
  %"multmp" = mul i32 %"h.1", 33
  %"c.2" = load i8, i8* %"c"
  %".19" = zext i8 %"c.2" to i32
  %"addtmp" = add i32 %"multmp", %".19"
  store i32 %"addtmp", i32* %"h"
  %"i.2" = load i32, i32* %"i"
  %"addtmp.1" = add i32 %"i.2", 1
  store i32 %"addtmp.1", i32* %"i"
  br label %"whilecond"
}

declare %"std_map_HashMap" @"std_map_HashMap_new"()

declare void @"std_map_HashMap_insert"(%"std_map_HashMap"* %".1", i8 %".2", i8 %".3")

declare {i32, [256 x i8]} @"std_map_HashMap_get"(%"std_map_HashMap"* %".1", i8 %".2")

declare i32 @"std_map_HashMap_len"(%"std_map_HashMap"* %".1")

define i32 @"main"()
{
entry:
  %".2" = call %"std_map_HashMap" @"std_map_HashMap_new"()
  %"map" = alloca %"std_map_HashMap<i32,i32>"
  %".3" = bitcast %"std_map_HashMap<i32,i32>"* %"map" to %"std_map_HashMap"*
  store %"std_map_HashMap" %".2", %"std_map_HashMap"* %".3"
  %"map.1" = load %"std_map_HashMap", %"std_map_HashMap"* %".3"
  %".5" = trunc i32 10 to i8
  %".6" = trunc i32 100 to i8
  call void @"std_map_HashMap_insert"(%"std_map_HashMap"* %".3", i8 %".5", i8 %".6")
  %"map.2" = load %"std_map_HashMap", %"std_map_HashMap"* %".3"
  %".8" = trunc i32 20 to i8
  %".9" = trunc i32 200 to i8
  call void @"std_map_HashMap_insert"(%"std_map_HashMap"* %".3", i8 %".8", i8 %".9")
  %"map.3" = load %"std_map_HashMap", %"std_map_HashMap"* %".3"
  %".11" = trunc i32 10 to i8
  %".12" = call {i32, [256 x i8]} @"std_map_HashMap_get"(%"std_map_HashMap"* %".3", i8 %".11")
  %".13" = call i8 @"std_option_Option_unwrap"({i32, [256 x i8]} %".12")
  %"v1" = alloca i32
  %".14" = bitcast i32* %"v1" to i8*
  store i8 %".13", i8* %".14"
  %"map.4" = load %"std_map_HashMap", %"std_map_HashMap"* %".3"
  %".16" = trunc i32 20 to i8
  %".17" = call {i32, [256 x i8]} @"std_map_HashMap_get"(%"std_map_HashMap"* %".3", i8 %".16")
  %".18" = call i8 @"std_option_Option_unwrap"({i32, [256 x i8]} %".17")
  %"v2" = alloca i32
  %".19" = bitcast i32* %"v2" to i8*
  store i8 %".18", i8* %".19"
  %"v1.1" = load i8, i8* %".14"
  %".21" = bitcast [4 x i8]* @"fmt_s" to i8*
  %".22" = bitcast i8 %"v1.1" to i8*
  %".23" = call i32 (i8*, ...) @"printf"(i8* %".21", i8* %".22")
  %"v2.1" = load i8, i8* %".19"
  %".24" = bitcast [4 x i8]* @"fmt_s.1" to i8*
  %".25" = bitcast i8 %"v2.1" to i8*
  %".26" = call i32 (i8*, ...) @"printf"(i8* %".24", i8* %".25")
  %"map.5" = load %"std_map_HashMap", %"std_map_HashMap"* %".3"
  %".27" = trunc i32 10 to i8
  %".28" = trunc i32 101 to i8
  call void @"std_map_HashMap_insert"(%"std_map_HashMap"* %".3", i8 %".27", i8 %".28")
  %"map.6" = load %"std_map_HashMap", %"std_map_HashMap"* %".3"
  %".30" = trunc i32 10 to i8
  %".31" = call {i32, [256 x i8]} @"std_map_HashMap_get"(%"std_map_HashMap"* %".3", i8 %".30")
  %".32" = call i8 @"std_option_Option_unwrap"({i32, [256 x i8]} %".31")
  %"v3" = alloca i32
  %".33" = bitcast i32* %"v3" to i8*
  store i8 %".32", i8* %".33"
  %"v3.1" = load i8, i8* %".33"
  %".35" = bitcast [4 x i8]* @"fmt_s.2" to i8*
  %".36" = bitcast i8 %"v3.1" to i8*
  %".37" = call i32 (i8*, ...) @"printf"(i8* %".35", i8* %".36")
  ret i32 0
}

@"fmt_s" = internal constant [4 x i8] c"%s\0a\00"
@"fmt_s.1" = internal constant [4 x i8] c"%s\0a\00"
@"fmt_s.2" = internal constant [4 x i8] c"%s\0a\00"