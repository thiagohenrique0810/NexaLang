fn is_alpha(c: u8) -> bool {
    let x: i32 = cast::<i32>(c)
    if (x > 64) { if (x < 91) { return true } }     # A-Z
    if (x > 96) { if (x < 123) { return true } }    # a-z
    if (x == 95) { return true }              # _
    return false
}

fn is_digit(c: u8) -> bool {
    let x: i32 = cast::<i32>(c)
    if (x > 47) { if (x < 58) { return true } }
    return false
}

fn is_space(c: u8) -> bool {
    let x: i32 = cast::<i32>(c)
    if (x == 32) { return true }  # space
    if (x == 9) { return true }   # \t
    if (x == 10) { return true }  # \n
    if (x == 13) { return true }  # \r
    return false
}

fn main() -> i32 {
    # Stage 2: a minimal lexer written in NexaLang (counts tokens).
    let src: Buffer<u8> = fs::read_file("examples/control.nxl")
    let p: *u8 = src.ptr
    let n: i32 = src.len

    let i: i32 = 0

    let count_ident: i32 = 0
    let count_number: i32 = 0
    let count_string: i32 = 0
    let count_char: i32 = 0
    let count_op: i32 = 0

    while (i < n) {
        let c: u8 = p[i]
        let consumed: bool = false

        # skip whitespace
        if (is_space(c)) {
            i = i + 1
            consumed = true
        }

        # comment: # ... \n
        if (consumed == false) {
            if (cast::<i32>(c) == 35) {
                let j: i32 = i + 1
                while (j < n) {
                    if (cast::<i32>(p[j]) == 10) { # newline
                        i = j
                        j = n
                    } else {
                        j = j + 1
                    }
                }
                consumed = true
            }
        }

        # string literal: " ... "
        if (consumed == false) {
            if (cast::<i32>(c) == 34) {
                count_string = count_string + 1
                let j: i32 = i + 1
                while (j < n) {
                    let cj: i32 = cast::<i32>(p[j])
                    if (cj == 34) { # closing quote
                        i = j + 1
                        j = n
                    } else {
                        # naive escape skip
                        if (cj == 92) { # backslash
                            if (j + 1 < n) { j = j + 2 } else { j = j + 1 }
                        } else {
                            j = j + 1
                        }
                    }
                }
                # if unterminated, just end
                if (i < n) { consumed = true } else { consumed = true }
            }
        }

        # char literal: 'a' / '\n'
        if (consumed == false) {
            if (cast::<i32>(c) == 39) {
                count_char = count_char + 1
                let j: i32 = i + 1
                if (j < n) {
                    if (cast::<i32>(p[j]) == 92) { # backslash
                        j = j + 2
                        # \xNN
                        if (j < n) {
                            if (cast::<i32>(p[j - 1]) == 120) { j = j + 2 }
                        }
                    } else {
                        j = j + 1
                    }
                }
                if (j < n) { if (cast::<i32>(p[j]) == 39) { j = j + 1 } }
                i = j
                consumed = true
            }
        }

        # identifier / keyword
        if (consumed == false) {
            if (is_alpha(c)) {
                count_ident = count_ident + 1
                let j: i32 = i + 1
                while (j < n) {
                    if (is_alpha(p[j])) {
                        j = j + 1
                    } else {
                        if (is_digit(p[j])) { j = j + 1 } else { i = j; j = n }
                    }
                }
                if (i < n) { consumed = true } else { consumed = true }
            }
        }

        # number
        if (consumed == false) {
            if (is_digit(c)) {
                count_number = count_number + 1
                let j: i32 = i + 1
                while (j < n) {
                    if (is_digit(p[j])) { j = j + 1 } else { i = j; j = n }
                }
                # float: .digits
                if (i + 1 < n) {
                    if (cast::<i32>(p[i]) == 46) { # '.'
                        if (is_digit(p[i + 1])) {
                            i = i + 1
                            let k: i32 = i
                            while (k < n) {
                                if (is_digit(p[k])) { k = k + 1 } else { i = k; k = n }
                            }
                        }
                    }
                }
                consumed = true
            }
        }

        # operators / punctuation (fallback)
        if (consumed == false) {
            count_op = count_op + 1
            i = i + 1
        }
    }

    print("Stage2 lexer stats:")
    print(count_ident)
    print(count_number)
    print(count_string)
    print(count_char)
    print(count_op)
    return 0
}


