<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NexaLang - Documenta√ß√£o Completa</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <h2>NexaLang</h2>
            <nav>
                <ul>
                    <li><a href="#introducao" class="active">Introdu√ß√£o</a></li>
                    <li><a href="#instalacao">Instala√ß√£o</a></li>
                    <li><a href="#sintaxe">Sintaxe B√°sica</a></li>
                    <li><a href="#tipos">Tipos de Dados</a></li>
                    <li><a href="#funcoes">Fun√ß√µes</a></li>
                    <li><a href="#structs">Structs</a></li>
                    <li><a href="#enums">Enums</a></li>
                    <li><a href="#generics">Generics</a></li>
                    <li><a href="#ownership">Ownership & Borrowing</a></li>
                    <li><a href="#regions">Regions</a></li>
                    <li><a href="#gpu">GPU Kernels</a></li>
                    <li><a href="#controle">Controle de Fluxo</a></li>
                    <li><a href="#arrays">Arrays & Slices</a></li>
                    <li><a href="#ponteiros">Ponteiros</a></li>
                    <li><a href="#stdlib">Standard Library</a></li>
                    <li><a href="#ferramentas">Ferramentas</a></li>
                    <li><a href="#metaprogramacao">Metaprograma√ß√£o & Testes</a></li>
                    <li><a href="#exemplos">Exemplos</a></li>
                </ul>
            </nav>
        </aside>

        <main class="main-content">
            <div class="header">
                <h1>NexaLang <span class="badge badge-version">v0.5</span> <span class="badge badge-status">Auto-Hospedada</span></h1>
                <p>A Linguagem Universal de Sistemas - Combinando seguran√ßa moderna com poder de baixo n√≠vel</p>
            </div>

            <section id="introducao">
                <h2>üöÄ Introdu√ß√£o</h2>
                <p>
                    <strong>NexaLang</strong> √© uma linguagem de programa√ß√£o de sistemas moderna e de alta performance, 
                    projetada para unificar computa√ß√£o CPU e GPU. Ela combina a seguran√ßa de linguagens modernas com 
                    o poder bruto de controle de baixo n√≠vel, tudo sem um coletor de lixo.
                </p>

                <div class="feature-grid">
                    <div class="feature-card">
                        <h4>üß† Gerenciamento H√≠brido de Mem√≥ria</h4>
                        <p>Seguro por padr√£o, manual quando necess√°rio. NexaLang usa <strong>Affine Ownership</strong> 
                        para prevenir vazamentos e data races em tempo de compila√ß√£o, mas permite gerenciamento baseado 
                        em <strong>Regions</strong> e blocos <code>unsafe</code> para drivers de hardware.</p>
                    </div>

                    <div class="feature-card">
                        <h4>‚ö° Kernels GPU Nativos</h4>
                        <p>Pare de escrever strings CUDA C++ no seu c√≥digo. NexaLang trata a GPU como cidad√£o de primeira classe. 
                        Escreva kernels diretamente na sintaxe padr√£o NexaLang e dispare-os perfeitamente.</p>
                    </div>

                    <div class="feature-card">
                        <h4>üîå Interop Zero-Cost</h4>
                        <p>Ligue diretamente com bibliotecas C e C++ sem overhead. Gere bindings Python e JavaScript 
                        automaticamente com a toolchain <code>nx</code>.</p>
                    </div>
                </div>

                <h3>Filosofia</h3>
                <p><em>"Control by Choice, Safety by Default"</em></p>
                <p>
                    NexaLang oferece controle total quando voc√™ precisa, mas seguran√ßa por padr√£o. Voc√™ pode optar por 
                    usar blocos <code>unsafe</code> quando necess√°rio, mas o compilador garante que voc√™ est√° ciente dos riscos.
                </p>
            </section>

            <section id="instalacao">
                <h2>üõ†Ô∏è Instala√ß√£o Global</h2>
                <p>NexaLang agora conta com um comando CLI unificado para facilitar o desenvolvimento.</p>

                <h3>Requisitos</h3>
                <ul>
                    <li><strong>LLVM / Clang</strong> (v15+ recomendado)</li>
                    <li><strong>Python 3.8+</strong> (para o gerenciador de build)</li>
                </ul>

                <h3>Configura√ß√£o no Windows</h3>
                <ol>
                    <li>Abra as <strong>Vari√°veis de Ambiente</strong> do sistema.</li>
                    <li>Adicione o caminho da pasta raiz do NexaLang ao seu <code>Path</code> de usu√°rio.</li>
                    <li>Reinicie o terminal.</li>
                </ol>

                <h3>Configura√ß√£o no Linux / macOS</h3>
                <pre><code># Na pasta do projeto
chmod +x nxc
sudo ln -s $(pwd)/nxc /usr/local/bin/nxc</code></pre>

                <h3>Uso da CLI</h3>
                <pre><code># Inicializar um novo projeto
nxpkg init meu_projeto

# Compilar e executar um arquivo
nxc run examples/hello.nxl

# Compilar para bin√°rio nativo otimizado
nxc build main.nxl --opt O3 --out meu_programa.exe

# Rodar todos os testes unit√°rios
nxc test meu_codigo.nxl</code></pre>
            </section>

            <section id="sintaxe">
                <h2>üìù Sintaxe B√°sica</h2>

                <h3>Hello World</h3>
                <pre><code>fn main() {
    print("Hello, NexaLang!")
}</code></pre>

                <h3>Vari√°veis</h3>
                <pre><code># Declara√ß√£o com tipo expl√≠cito
let x: i32 = 42

# Infer√™ncia de tipo
let y = 100  # tipo inferido como i32

# Mutabilidade (padr√£o √© imut√°vel)
let mut counter = 0
counter = counter + 1</code></pre>

                <h3>Coment√°rios</h3>
                <pre><code># Coment√°rio de linha √∫nica

/* 
   Coment√°rio de m√∫ltiplas linhas
   (Estilo C)
*/</code></pre>
            </section>

            <section id="tipos">
                <h2>üî¢ Tipos de Dados</h2>

                <h3>Tipos Primitivos</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Tipo</th>
                            <th>Descri√ß√£o</th>
                            <th>Tamanho</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>i32</code></td>
                            <td>Inteiro com sinal de 32 bits</td>
                            <td>4 bytes</td>
                        </tr>
                        <tr>
                            <td><code>i64</code></td>
                            <td>Inteiro com sinal de 64 bits</td>
                            <td>8 bytes</td>
                        </tr>
                        <tr>
                            <td><code>u8</code></td>
                            <td>Inteiro sem sinal de 8 bits</td>
                            <td>1 byte</td>
                        </tr>
                        <tr>
                            <td><code>bool</code></td>
                            <td>Booleano (true/false)</td>
                            <td>1 byte</td>
                        </tr>
                        <tr>
                            <td><code>f32</code></td>
                            <td>Ponto flutuante de 32 bits</td>
                            <td>4 bytes</td>
                        </tr>
                        <tr>
                            <td><code>char</code></td>
                            <td>Caractere Unicode</td>
                            <td>4 bytes</td>
                        </tr>
                        <tr>
                            <td><code>string</code></td>
                            <td>String (equivalente a <code>i8*</code>)</td>
                            <td>Ponteiro</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Literais</h3>
                <pre><code>let int_literal = 42
let float_literal = 3.14
let bool_literal = true
let char_literal = 'A'
let string_literal = "Hello"</code></pre>
            </section>

            <section id="funcoes">
                <h2>‚öôÔ∏è Fun√ß√µes</h2>

                <h3>Defini√ß√£o de Fun√ß√µes</h3>
                <pre><code># Fun√ß√£o sem retorno
fn greet(name: string) {
    print(name)
}

# Fun√ß√£o com retorno
fn add(a: i32, b: i32) -> i32 {
    return a + b
}

# Fun√ß√£o com express√£o de retorno impl√≠cita
fn multiply(x: i32, y: i32) -> i32 {
    x * y  # √∫ltima express√£o √© retornada
}</code></pre>

                <h3>Chamada de Fun√ß√µes</h3>
                <pre><code>greet("NexaLang")
let result = add(10, 20)</code></pre>
            </section>

            <section id="structs">
                <h2>üèóÔ∏è Structs</h2>

                <h3>Defini√ß√£o</h3>
                <pre><code>struct Vector3 {
    x: i32,
    y: i32,
    z: i32
}</code></pre>

                <h3>Instancia√ß√£o</h3>
                <pre><code>let v: Vector3 = Vector3(10, 20, 30)
print(v.x)  # 10
print(v.y)  # 20</code></pre>

                <h3>M√©todos (impl blocks)</h3>
                <pre><code>struct Vector {
    x: i32,
    y: i32
}

impl Vector {
    # M√©todo est√°tico
    fn new(x: i32, y: i32) -> Vector {
        return Vector(x, y)
    }
    
    # M√©todo de inst√¢ncia (refer√™ncia imut√°vel)
    fn dot(&self, other: Vector) -> i32 {
        let a = self.x * other.x
        let b = self.y * other.y
        return a + b
    }
}

fn main() {
    let v1 = Vector::new(10, 20)
    let v2 = Vector::new(3, 4)
    let prod = v1.dot(v2)  # M√©todo de inst√¢ncia
}</code></pre>
            </section>

            <section id="enums">
                <h2>üé≤ Enums</h2>

                <h3>Defini√ß√£o</h3>
                <pre><code>enum Result {
    Ok(i32),
    Err(i32)
}</code></pre>

                <h3>Uso com Pattern Matching</h3>
                <pre><code>let res: Result = Result::Ok(42)

match res {
    Ok(val) => print(val),
    Err(code) => panic("Erro")
}</code></pre>

                <div class="alert alert-info">
                    <strong>Nota:</strong> O pattern matching deve ser exaustivo - todos os casos devem ser cobertos.
                </div>
            </section>

            <section id="generics">
                <h2>üîÄ Generics</h2>

                <h3>Structs Gen√©ricos</h3>
                <pre><code>struct Box&lt;T&gt; {
    item: T
}

let b = Box::&lt;i32&gt;(123)</code></pre>

                <h3>Fun√ß√µes Gen√©ricas</h3>
                <pre><code>fn id&lt;T&gt;(x: T) -> T {
    return x
}

let n = id::&lt;i32&gt;(456)</code></pre>

                <div class="alert alert-info">
                    <strong>TurboFish:</strong> Use <code>::&lt;Tipo&gt;</code> para especificar tipos gen√©ricos explicitamente.
                </div>
            </section>

            <section id="ownership">
                <h2>üîí Ownership & Borrowing</h2>

                <p>
                    NexaLang usa um sistema de <strong>Affine Ownership</strong> similar ao Rust. Por padr√£o, 
                    tipos n√£o-Copy s√£o movidos quando atribu√≠dos ou passados como argumentos.
                </p>

                <h3>Move Sem√¢ntics</h3>
                <pre><code>struct Foo {
    x: i32
}

fn take(foo: Foo) {
    print(foo.x)
}

fn main() {
    let f: Foo = Foo(123)
    take(f)        # move - ownership transferido
    print(f.x)     # ERRO: use after move
}</code></pre>

                <h3>Borrowing (Empr√©stimo)</h3>
                <pre><code># Borrow imut√°vel (&T)
fn read(foo: &Foo) {
    print(foo.x)  # Apenas leitura
}

# Borrow mut√°vel (&mut T)
fn modify(foo: &mut Foo) {
    foo.x = 999  # Modifica√ß√£o permitida
}

fn main() {
    let mut f = Foo(123)
    read(&f)           # M√∫ltiplos borrows imut√°veis OK
    modify(&mut f)    # Apenas um borrow mut√°vel por vez
}</code></pre>

                <div class="alert alert-warning">
                    <strong>Regras de Borrowing:</strong>
                    <ul>
                        <li>M√∫ltiplos borrows imut√°veis s√£o permitidos simultaneamente</li>
                        <li>Apenas um borrow mut√°vel por vez</li>
                        <li>N√£o √© poss√≠vel ter borrow mut√°vel e imut√°vel ao mesmo tempo</li>
                    </ul>
                </div>
            </section>

            <section id="regions">
                <h2>üóÇÔ∏è Regions (Arenas)</h2>

                <p>
                    <strong>Regions</strong> permitem gerenciamento de mem√≥ria baseado em arenas. 
                    Toda a mem√≥ria alocada em uma regi√£o √© liberada quando a regi√£o sai de escopo.
                </p>

                <pre><code>fn process_transaction() {
    region temp_arena {
        let user = User::new(in temp_arena)
        let cart = Cart::new(in temp_arena)
        # ... processamento pesado ...
    }  # temp_arena dropped aqui - desaloca√ß√£o O(1) instant√¢nea
}</code></pre>

                <div class="alert alert-success">
                    <strong>Vantagem:</strong> Desaloca√ß√£o em O(1) - toda a mem√≥ria da arena √© liberada de uma vez.
                </div>
            </section>

            <section id="gpu">
                <h2>üéÆ GPU Kernels</h2>

                <p>
                    Uma das features principais do NexaLang √© tratar a GPU como um contexto de execu√ß√£o padr√£o. 
                    Voc√™ pode escrever kernels diretamente em NexaLang usando a palavra-chave <code>kernel</code>.
                </p>

                <h3>Defini√ß√£o de Kernel</h3>
                <pre><code>kernel fn compute_physics(particles: Buffer&lt;Particle&gt;) {
    let i = gpu::global_id().x
    # L√≥gica executa na GPU
    particles[i].velocity = particles[i].velocity * 0.99
}</code></pre>

                <h3>Dispatch de Kernel</h3>
                <pre><code>fn main() {
    let particles = load_particles()
    # Dispara kernel na GPU
    gpu::dispatch(compute_physics, args: (particles,), threads: 1024)
}</code></pre>

                <h3>SPIR-V Backend</h3>
                <p>O compilador pode gerar c√≥digo SPIR-V para execu√ß√£o em GPUs compat√≠veis:</p>
                <pre><code>python bootstrap/main.py examples/gpu_kernel.nxl --target spirv --emit spv --out kernel.spv</code></pre>

                <div class="alert alert-info">
                    <strong>Suporte Vulkan:</strong> O compilador suporta ambiente Vulkan com <code>--spirv-env vulkan</code>.
                </div>
            </section>

            <section id="controle">
                <h2>üîÑ Controle de Fluxo</h2>

                <h3>If/Else</h3>
                <pre><code>if (x > 10) {
    print("Maior que 10")
} else {
    print("Menor ou igual a 10")
}</code></pre>

                <h3>While Loops</h3>
                <pre><code>let mut i = 0
while (i < 10) {
    print(i)
    i = i + 1
}</code></pre>

                <h3>Match (Pattern Matching)</h3>
                <pre><code>match status {
    Ok(val) => print("Sucesso: " + val),
    Err(e) => print("Erro: " + e),
    _ => print("Desconhecido")
}</code></pre>
            </section>

            <section id="arrays">
                <h2>üì¶ Arrays & Slices</h2>

                <h3>Arrays</h3>
                <pre><code># Array de tamanho fixo
let arr: [i32:5] = [1, 2, 3, 4, 5]
print(arr[0])  # 1

# Acesso por √≠ndice
arr[2] = 99</code></pre>

                <h3>Slices</h3>
                <pre><code># Criar slice a partir de array
let arr: [i32:10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
let slice = slice_from_array(&arr)

# Acesso a slice
print(slice.len)  # 10
print(slice[0])   # 1</code></pre>
            </section>

            <section id="ponteiros">
                <h2>üìç Ponteiros</h2>

                <h3>Tipos de Ponteiro</h3>
                <pre><code># Ponteiro imut√°vel
let x: i32 = 42
let ptr: *i32 = &x

# Ponteiro mut√°vel
let mut y: i32 = 100
let mut_ptr: *mut i32 = &mut y

# Dereferencia√ß√£o
*ptr = 99
print(*ptr)  # 99</code></pre>

                <h3>Opera√ß√µes com Ponteiros</h3>
                <pre><code># Aritm√©tica de ponteiros
let next = ptr_offset::&lt;i32&gt;(ptr, 1)

# Tamanho de tipo
let size = sizeof::&lt;i32&gt;()  # 4

# Cast de ponteiros
let raw: *u8 = cast::&lt;*u8&gt;(ptr)</code></pre>
            </section>

            <section id="stdlib">
                <h2>üìö Standard Library</h2>

                <h3>Fun√ß√µes Built-in</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Fun√ß√£o</th>
                            <th>Descri√ß√£o</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>print(value)</code></td>
                            <td>Imprime um valor no console</td>
                        </tr>
                        <tr>
                            <td><code>panic(message)</code></td>
                            <td>Aborta o programa com mensagem de erro</td>
                        </tr>
                        <tr>
                            <td><code>assert(condition, message)</code></td>
                            <td>Verifica condi√ß√£o e aborta se falsa</td>
                        </tr>
                        <tr>
                            <td><code>malloc(size: i32) -> *u8</code></td>
                            <td>Aloca mem√≥ria dinamicamente</td>
                        </tr>
                        <tr>
                            <td><code>free(ptr: *u8)</code></td>
                            <td>Libera mem√≥ria alocada</td>
                        </tr>
                        <tr>
                            <td><code>memcpy(dest, src, size)</code></td>
                            <td>Copia mem√≥ria</td>
                        </tr>
                        <tr>
                            <td><code>fs::read_file(path: string) -> Buffer&lt;u8&gt;</code></td>
                            <td>L√™ arquivo do sistema de arquivos</td>
                        </tr>
                        <tr>
                            <td><code>fs::write_file(path, data, len)</code></td>
                            <td>Escreve arquivo no sistema de arquivos</td>
                        </tr>
                        <tr>
                            <td><code>gpu::global_id() -> i32</code></td>
                            <td>Retorna ID global do thread GPU</td>
                        </tr>
                        <tr>
                            <td><code>gpu::dispatch(kernel, args, threads)</code></td>
                            <td>Dispara kernel na GPU</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Tipos Built-in</h3>
                <ul>
                    <li><code>Buffer&lt;T&gt;</code> - Buffer gen√©rico (usado para GPU)</li>
                    <li><code>Slice&lt;T&gt;</code> - Slice gen√©rico</li>
                    <li><code>Vec&lt;T&gt;</code> - Vetor din√¢mico</li>
                    <li><code>Option&lt;T&gt;</code> - Tipo opcional (enum)</li>
                    <li><code>Result&lt;T, E&gt;</code> - Tipo de resultado (enum)</li>
                </ul>
            </section>

            <section id="ferramentas">
                <h2>üõ†Ô∏è Ferramentas</h2>

                <h3>CLI `nx`</h3>
                <p>Ferramenta de linha de comando para gerenciar projetos NexaLang:</p>
                <pre><code># Executar arquivo
python nx.py run examples/hello.nxl

# Compilar para SPIR-V
python nx.py build examples/gpu_kernel.nxl --target spirv --emit spv --spv-out kernel.spv

# Validar SPIR-V
python nx.py val spirv kernel.spv</code></pre>

                <h3>VSCode Extension</h3>
                <p>Extens√£o de syntax highlighting para VSCode dispon√≠vel em <code>vscode-nexalang/</code>.</p>

                <h3>Ferramentas de Build</h3>
                <ul>
                    <li><strong>Compilador Bootstrap:</strong> Python-based, gera LLVM IR</li>
                    <li><strong>Targets:</strong> Native, SPIR-V (OpenCL/Vulkan)</li>
                    <li><strong>Output:</strong> LLVM IR (.ll), SPIR-V (.spv), Bin√°rio nativo</li>
                </ul>
            </section>

            <section id="metaprogramacao">
                <h2>üß™ Metaprograma√ß√£o & Testes</h2>
                
                <h3>Atributos</h3>
                <p>NexaLang utiliza atributos <code>@[nome]</code> para anexar metadados e comportamentos especiais a fun√ß√µes e estruturas.</p>

                <h3>Testes Unit√°rios</h3>
                <p>Marque fun√ß√µes com <code>@[test]</code> para inclu√≠-las no runner de testes integrado.</p>
                <pre><code>@[test]
fn test_soma() {
    assert(1 + 1 == 2, "Erro na soma")
}</code></pre>

                <h3>Deriva√ß√£o Autom√°tica</h3>
                <p>Use <code>@[derive(Debug)]</code> para gerar automaticamente m√©todos √∫teis, como o <code>debug_print()</code>.</p>
                <pre><code>@[derive(Debug)]
struct Point { x: i32, y: i32 }

fn main() {
    let p = Point(10, 20)
    p.debug_print() # Sa√≠da: Point { x: 10, y: 20 }
}</code></pre>
            </section>

            <section id="exemplos">
                <h2>üí° Exemplos</h2>

                <h3>Exemplo 1: Hello World</h3>
                <pre><code>fn main() {
    print("Hello, NexaLang!")
}</code></pre>

                <h3>Exemplo 2: Struct com M√©todos</h3>
                <pre><code>struct Point {
    x: i32,
    y: i32
}

impl Point {
    fn new(x: i32, y: i32) -> Point {
        return Point(x, y)
    }
    
    fn distance(&self, other: &Point) -> f32 {
        let dx = self.x - other.x
        let dy = self.y - other.y
        # C√°lculo simplificado
        return cast::&lt;f32&gt;(dx * dx + dy * dy)
    }
}

fn main() {
    let p1 = Point::new(0, 0)
    let p2 = Point::new(3, 4)
    print(p1.distance(&p2))
}</code></pre>

                <h3>Exemplo 3: GPU Kernel</h3>
                <pre><code>kernel fn vector_add(a: Buffer&lt;f32&gt;, b: Buffer&lt;f32&gt;, result: Buffer&lt;f32&gt;) {
    let i = gpu::global_id().x
    if (i < a.len) {
        result[i] = a[i] + b[i]
    }
}

fn main() {
    let a = create_buffer(1000)
    let b = create_buffer(1000)
    let result = create_buffer(1000)
    
    gpu::dispatch(vector_add, args: (a, b, result), threads: 1000)
}</code></pre>
            </section>

            <div class="footer">
                <p>NexaLang - The Universal Systems Language</p>
                <p>Designed by <strong>Thiago Henrique</strong></p>
                <p>Vers√£o 0.1 - Em Desenvolvimento</p>
            </div>
        </main>
    </div>

    <script src="highlight.js"></script>
    <script src="main.js"></script>
    <script>
        // For√ßa execu√ß√£o ap√≥s tudo estar carregado
        window.addEventListener('load', function() {
            setTimeout(function() {
                if (typeof window.highlightNexaLang === 'function') {
                    window.highlightNexaLang();
                }
            }, 100);
        });
        
        // Tamb√©m executa quando o DOM estiver pronto
        if (document.readyState === 'complete') {
            setTimeout(function() {
                if (typeof window.highlightNexaLang === 'function') {
                    window.highlightNexaLang();
                }
            }, 200);
        }
    </script>
</body>
</html>

